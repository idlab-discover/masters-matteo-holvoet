Below is a combined YAML manifest file that includes configurations for deploying WordPress and MySQL with a persistent storage solution and secret management, all set in a single YAML file for Kubernetes. Ensure each section is appropriately separated and apply this configuration to your Kubernetes cluster.

```yaml
---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  mysql-root-password: <YOUR_BASE64_ENCODED_ROOT_PASSWORD>
  mysql-password: <YOUR_BASE64_ENCODED_PASSWORD>

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-root-password
        - name: MYSQL_DATABASE
          value: wordpress
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  type: LoadBalancer
  selector:
    app: wordpress
```

**Important Notes:**
1. Replace `<YOUR_BASE64_ENCODED_ROOT_PASSWORD>` and `<YOUR_BASE64_ENCODED_PASSWORD>` with your base64-encoded password values. Remember to encode your passwords with the command `echo -n "password_here" | base64` before placing them in the manifest.
2. Deployments are configured to use Resources and Secrets effectively.
3. Services are set up to expose the applications. For WordPress, it uses a LoadBalancer type which would typically be used in cloud environments. For on-premise setups, you might want to use NodePort or set up an Ingress controller instead.

Before applying this configuration, make sure that your Kubernetes cluster supports all used API versions and that the storage size and type are adjusted according to your actual needs and availability.