Creating a Kubernetes YAML manifest to deploy a WordPress website with a MySQL database backend involves several components. We'll need to set up Deployments for both WordPress and MySQL, create Services to expose them, and manage the persistent storage via PersistentVolumeClaims. 

Here's a step-by-step method to create the necessary Kubernetes manifest.

### Step 1: MySQL Deployment

1. **MySQL Deployment**: We'll start by deploying MySQL. It needs a PersistentVolumeClaim for storing data, a Deployment to manage the pods, and a Service for network access.

**MySQL PersistentVolumeClaim**:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

**MySQL Deployment**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: mysql123
        - name: MYSQL_DATABASE
          value: wordpress
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

**MySQL Service**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  type: ClusterIP
```

### Step 2: WordPress Deployment

2. **WordPress Deployment**: Similar to MySQL, you will need a PersistentVolumeClaim for WordPress, a Deployment, and a Service.

**WordPress PersistentVolumeClaim**:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

**WordPress Deployment**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          value: mysql123
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wp-pv-claim
```

**WordPress Service**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Final Integration

The MySQL and WordPress installations are linked using environment variables (i.e., `WORDPRESS_DB_HOST` and `WORDPRESS_DB_PASSWORD`) that point to the MySQL service and use credentials configured in the MySQL deployment. WordPress can communicate with MySQL since both are in the same Kubernetes cluster and namespace.

To deploy this setup:
1. Save this configuration into a file (e.g., `wordpress-mysql-deployment.yml`).
2. Apply the configuration using `kubectl apply -f wordpress-mysql-deployment.yml`.

This will set up a WordPress site with a MySQL backend, using persistent storage and Kubernetes services to expose the WordPress site.