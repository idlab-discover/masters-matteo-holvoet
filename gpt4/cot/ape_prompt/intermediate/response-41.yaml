Sure, let's work through this! We will create a simple Kubernetes deployment and service configuration for both WordPress and MySQL. Each component will run in its own pod, and we'll ensure that only WordPress is accessible from outside the Kubernetes cluster.

#### Step 1: Create a secret for MySQL
First, we start by creating a Kubernetes secret to store the MySQL password. This is important for security reasons, so that we don't expose sensitive database credentials directly in our deployment configuration.

Here is the YAML to create a secret named `mysql-pass`:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
```
Remember to replace `YOUR_BASE64_ENCODED_PASSWORD` with the base64-encoded form of the password you wish to use. You can generate a base64 version of your password like this:
```bash
echo -n 'yourpassword' | base64
```
Replace `yourpassword` with your actual password.

#### Step 2: MySQL Deployment and Service
Next, we'll deploy MySQL. This includes defining both the Deployment and the corresponding Service to expose MySQL within the cluster:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

You'll also need to make sure you have a PersistentVolumeClaim (PVC) ready for MySQL, otherwise, you'd need to add a PVC definition.

#### Step 3: WordPress Deployment and Service
Now, let's do the similar setup for WordPress:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
          name: wordpress
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  type: LoadBalancer
  selector:
    app: wordpress
```

Similarly, ensure a PVC for WordPress `wordpress-pvc` is configured or include its definition similarly to MySQL above.

#### Step 4: Apply to Your Cluster
To deploy, make sure your `kubectl` command line tool is set up properly with the target cluster, then run:
```bash
kubectl apply -f wordpress-mysql.yaml
```
Where `wordpress-mysql.yaml` is the file containing all the YAML configurations above.

#### Conclusion
This setup provides a foundational start for deploying WordPress and MySQL on Kubernetes. Be sure to replace placeholders, especially the password, and handle data persistence correctly with proper PVC configurations depending on your cluster's environment and storage capabilities. Further steps would involve securing WordPress deployment, managing backups, and scaling configurations based on load and resources.