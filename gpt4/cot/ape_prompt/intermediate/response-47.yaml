Creating a Kubernetes deployment for a WordPress site using a MySQL database involves multiple steps, each of which must be carefully crafted to ensure the system operates smoothly. You will need Deployment objects for both WordPress and MySQL, a persistent volume and persistent volume claim for data persistence, services to expose and load-balance access to both WordPress and MySQL, and environment variables to store sensitive data like database passwords. Hereâ€™s how to set this up, step-by-step.

### Step 1: Persistent Volumes and Persistent Volume Claims

First, you need persistent storage for the MySQL database to ensure that the data is not lost when the pod restarts. You will define Persistent Volume Claims (PVCs) which will be used by your MySQL deployment.

1. **MySQL PersistentVolumeClaim**:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### Step 2: MySQL Deployment

Create a Kubernetes Secret to store the MySQL root password, followed by a deployment definition for MySQL.

1. **MySQL Secret**:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: BASE64_ENCODED_PASSWORD  # Replace BASE64_ENCODED_PASSWORD with your base64-encoded password
```

2. **MySQL Deployment**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

3. **MySQL Service**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None  # This makes it a headless service
```

### Step 3: WordPress Deployment

Finally, you create a deployment and service for WordPress that connects to the MySQL database you just set up.

1. **WordPress Deployment**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql  # Must match MySQL service name
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
```

2. **WordPress Service**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Deploying the Manifests

To initiate the deployment, apply each of these manifests in your Kubernetes cluster using kubectl commands:

```bash
kubectl apply -f <filename>.yaml
```

Ensure to replace `<filename>` with the appropriate file names where you've saved each YAML config.

This outline creates a minimal architecture for a WordPress website with a MySQL backend on Kubernetes. You can expand from here, adding other necessary configurations like security (e.g., using Network Policies), scalability settings, or more complex persistent storage options.