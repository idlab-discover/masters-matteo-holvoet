To deploy a WordPress website with a MySQL database in Kubernetes, we will need to define a few objects in our YAML file(s):

1. **Persistent Volumes (PV)** and **Persistent Volume Claims (PVC)** to store data for both WordPress and MySQL.
2. **Deployments** for both WordPress and MySQL.
3. A **Service** for each deployment to allow network access.

We will break down the YAML creation process into separate parts for clarity.

### Step 1: Persistent Volume Claims (PVC)

First, we create Persistent Volume Claims for MySQL and WordPress. Here, Kubernetes volumes abstract the details of how the storage is provided and how it's consumed. We assume the Persistent Volumes that meet these claims already exist or will be dynamically provisioned using a StorageClass (not explicitly stated here but assumed for simplification).

#### MySQL Persistent Volume Claim

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
```

#### WordPress Persistent Volume Claim

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

### Step 2: MySQL Deployment

Defining a MySQL deployment requires setting up the container and linking it to the persistent storage.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - image: mysql:5.7
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: yourpassword
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wpuser
        - name: MYSQL_PASSWORD
          value: wppassword
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 3: MySQL Service

This service will expose MySQL to WordPress within the cluster.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None
```

### Step 4: WordPress Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - image: wordpress:latest
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: wpuser
        - name: WORDPRESS_DB_PASSWORD
          value: wppassword
        - name: WORDPRESS_DB_NAME
          value: wordpress
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim
```

### Step 5: WordPress Service

This service will make WordPress accessible through a node port or a load balancer, depending on your environment.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
    tier: frontend
  type: LoadBalancer
```

These YAML definitions provided step-by-step will create a Kubernetes infrastructure where WordPress and MySQL interact over persistent storage and are configured according to best practices, with MySQL not being directly exposed to the outside world whereas WordPress is.

Remember to replace sensitive data such as passwords with secrets or environment-specific configurations before deploying into a production environment.