To create a Kubernetes manifest for a WordPress website with a MySQL database backend, you will need to configure multiple components:

1. **MySQL Deployment**: This will run the MySQL database in a container.
2. **WordPress Deployment**: This will run the WordPress software in a container.
3. **Services**: To expose and load balance the deployments and allow them to communicate.

Hereâ€™s a step-by-step YAML configuration for deploying WordPress and MySQL on a Kubernetes cluster:

### Step 1: Define MySQL Password
For the security of communications between WordPress and MySQL, define a Secret that holds the password.

**mysql-secret.yaml**:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
```
Replace `YOUR_BASE64_ENCODED_PASSWORD` with a Base64 encoded password. To generate a Base64 encoded password you can use: `echo -n "yourpassword" | base64`.

### Step 2: MySQL Deployment
The MySQL container will use the Secret created above for its password.

**mysql-deployment.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```
This does not include definitions for PersistentVolume or PersistentVolumeClaim, which you would need to define based on your environment specifics (cloud provider, local storage, etc.).

### Step 3: MySQL Service
A Kubernetes Service is needed to expose the MySQL deployment within the cluster.

**mysql-service.yaml**:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```
This service creates a DNS entry inside the cluster for "mysql" that allows other pods to resolve and connect to this service over port 3306.

### Step 4: WordPress Deployment
Now configure WordPress to use the MySQL database.

**wordpress-deployment.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: "mysql"
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
```
### Step 5: WordPress Service
Expose WordPress to the outside world.

**wordpress-service.yaml**:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```
This configuration creates a LoadBalancer service which exposes the WordPress site to the Internet on port 80 using the load balancer provided by your Kubernetes cluster environment.

Make sure you replace placeholders with actual meaningful and secure values where necessary. Also, consider adding readiness and liveness probes to your deployments for better resilience and management.