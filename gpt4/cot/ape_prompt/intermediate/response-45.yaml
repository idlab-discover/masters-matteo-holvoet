Creating a Kubernetes YAML manifest to deploy a WordPress website with a MySQL database involves several steps. We will need to define a few different resources:

1. **Secrets**: To securely store database credentials.
2. **Persistent Volume Claims (PVCs)**: To ensure that the data stored in the database and WordPress persists across pod recreations.
3. **Deployments**: To manage the WordPress and MySQL containers.
4. **Services**: To expose WordPress and MySQL within the cluster.

### Step 1: Create Kubernetes Secret
First, we need to create a Kubernetes Secret to store the MySQL root password and WordPress database password. Replace `<mysql-root-password>` and `<wordpress-db-password>` with your desired passwords.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  mysql-root-password: <base64-encoded-password>
  wordpress-db-password: <base64-encoded-password>
```
You need to encode your passwords in base64 format. You can use the command `echo -n 'your-password' | base64` to generate these values.

### Step 2: Persistent Volume Claims
Next, define PVCs for MySQL and WordPress for data durability.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Step 3: MySQL Deployment
Now, create a MySQL deployment using the secret for the password.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-root-password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 4: WordPress Deployment
Similarly, create a WordPress deployment that connects to the MySQL service.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: wordpress-db-password
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim
```

### Step 5: Services
Finally, we need to expose the MySQL and WordPress deployments via services.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

This setup creates a LoadBalancer service for WordPress, which makes it accessible via an external IP, and a `ClusterIP` service for MySQL, which is only accessible within the cluster.

Apply these YAML files to your Kubernetes cluster to get WordPress and MySQL up and running. Make sure to follow security best practices and manage and monitor your cluster's resources efficiently.