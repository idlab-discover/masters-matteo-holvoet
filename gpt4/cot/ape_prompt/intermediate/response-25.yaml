Creating a Kubernetes YAML manifest for a WordPress website using a MySQL database involves several components. We need to set up the MySQL database and the WordPress application itself, along with the necessary persistent storage and networking resources. This example will show you how to do this step-by-step using Kubernetes deployments, services, persistent volume claims (PVCs), and secrets for sensitive data like passwords.

### Step 1: Define MySQL Secrets

First, let's create a Kubernetes Secret to store the MySQL root password and WordPress database password securely.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  mysql-root-password: c2VjdXJlcGFzc3dvcmQ=   # Encoded in Base64 (e.g., 'securepassword')
  mysql-password: d3BwYXNz # Encoded in Base64 (e.g., 'wppass')
```
You can generate a Base64 version of your passwords using `echo -n 'mypassword' | base64`.

### Step 2: Create MySQL Deployment

Now let's deploy MySQL:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.6
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-root-password
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wpuser
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```
### Step 3: Create MySQL PersistentVolumeClaim

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Step 4: Create MySQL Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None  # This is a headless service
```

### Step 5: Deploy WordPress

Next, set up the WordPress deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: wpuser
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        - name: WORDPRESS_DB_NAME
          value: wordpress
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
```

### Step 6: Create WordPress PersistentVolumeClaim

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Step 7: Create WordPress Service

Finally, expose WordPress with a service:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress
```

These YAML files create a minimal, functioning WordPress site on Kubernetes with MySQL as the backend database, using secrets for sensitive information, persistent storage to maintain data across pod cycling, and services to enable network access to both MySQL and WordPress.