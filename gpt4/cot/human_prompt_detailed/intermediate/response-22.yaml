Great! We'll create a Kubernetes YAML manifest step-by-step to achieve your goals. Hereâ€™s how we can structure this:

1. **MYSQL Deployment**, Service, Secret, and PersistentVolumeClaim.
2. **WordPress Deployment** and Service.
3. **ConfigMap** for configuring some WordPress settings.
4. **Secrets** to securely store database credentials.

### Step 1: MySQL Deployment and Service

We'll start by defining a Secret for the MySQL database credentials, a PersistentVolumeClaim for data persistence, a Deployment for the MySQL database, and a Service to expose MySQL.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Step 2: WordPress Deployment and Service

Now, setup the WordPress deployment with the necessary environment variables and a service to expose it.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql-service
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: WORDPRESS_DB_NAME
          value: wordpress

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress-service
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress
```

We used the secret "mysql-pass" to pass the MySQL root password to both the MySQL and WordPress deployments, ensuring that the password is not exposed in plain text.

### Step 3: ConfigMap (Optional)

Here, you might want to add configurations for WordPress. Currently, with this basic setup, there's no immediate need for extra configmaps unless you have specific WordPress configurations to map.

### Conclusion

With the above manifest, you have a MySQL deployment utilizing a persistent volume claim for data storage and a WordPress deployment that connects to your MySQL instance securely, using a Kubernetes Secret. A service exposes the WordPress application to traffic. Make sure to replace `YOUR_BASE64_ENCODED_PASSWORD` in the secret with a base64 encoded string of your desired password.

Let me know if there's any specific WordPress configuration or another aspect you want added to this setup!