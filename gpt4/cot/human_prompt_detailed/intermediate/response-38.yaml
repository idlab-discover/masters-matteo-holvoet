To create a Kubernetes YAML manifest that fulfills these requirements, we will need to structure it as follows:

1. **Secrets**: For storing sensitive data such as the MySQL root password, and the WordPress database password.
2. **ConfigMaps**: For storing non-sensitive configuration options such as database name, database user, etc.
3. **PersistentVolumeClaims (PVCs)**: Define requests for persistent storage for the MySQL database.
4. **Deployments**: Define the deployment specifications for both MySQL and WordPress, including their container images, environment configuration using the previously defined ConfigMaps and Secrets, volumes, etc.
5. **Services**: Define services for both WordPress and MySQL to enable network access to them.

Let's define each of these in our YAML file step-by-step:

First, Set up Secrets and ConfigMaps:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  mysql-root-password: bXlzcWxyb290cGFzcw==  # Base64 encoding of "mysqlrootpass"
  mysql-password: d29yZHByZXNz # Base64 encoding of "wordpress"

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  mysql-user: wordpress
  mysql-database: wordpress

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wp-config
data:
  wp-user: wordpress
  wp-database: wordpress
```

Now, define the PersistentVolumeClaims for MySQL:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

Define the Deployments:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  replicas: 1
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: wp-config
              key: wp-user
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: wp-config
              key: wp-database

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-root-password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: mysql-database
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: mysql-user
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

Finally, define the Services:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30080
  selector:
    app: wordpress

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
```

This YAML file sets up WordPress and MySQL with basic parameters using best practices like separating secrets and making MySQL data persistent across deploys. Adjust the storage size, image versions, and environment variables as necessary for your specific use case.