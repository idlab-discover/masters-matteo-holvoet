To meet the requirements outlined, I will guide you through constructing a Kubernetes YAML manifest structured to define Deployments for both a WordPress site and a MySQL database, complete with related services, persistent volume claims, ConfigMaps, and a Secret. Here is a step-by-step explanation along with the YAML configuration.

### Step 1: Define ConfigMap and Secret

First, we'll create a ConfigMap to store configuration data that isn't sensitive. We will then define a Secret to store sensitive data, specifically the MySQL password.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  # MySQL database host name
  MYSQL_HOST: wordpress-mysql

---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  # Base64 encoded MySQL password (example: "mysqlpassword")
  mysql-password: bXlzcWxwYXNzd29yZA==
```

### Step 2: MySQL Deployment with Persistent Storage

Next, we set up the MySQL deployment. This will use a `PersistentVolumeClaim` to ensure data persistence.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 3: MySQL Service

A service for MySQL ensures that the database is accessible to the WordPress pod.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Step 4: WordPress Deployment

For the WordPress deployment, we connect to the MySQL database utilizing the earlier configurations.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: MYSQL_HOST
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
```

### Step 5: WordPress Service

Finally, expose the WordPress instance with a service so it's accessible from outside the cluster.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Final Assembly

All these components (ConfigMap, Secret, PVC, two Deployments, and two Services) need to be declared in a single YAML file or split into multiple files within the same directory. They should be applied to the Kubernetes cluster using `kubectl apply -f <filename.yaml>` or `kubectl apply -f <directory>/` for a directory.

This setup ensures that the WordPress and MySQL instances are properly linked, using ConfigMaps and Secrets to manage configuration and sensitive data, and Services to allow network access to the pods.