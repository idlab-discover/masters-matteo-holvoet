Sure, let's build the YAML manifest for a Kubernetes deployment of a WordPress website using MySQL as a backend step by step. We'll ensure that configurations, such as sensitive data, are managed via ConfigMaps and Secrets, and use PersistentVolumeClaims for MySQL data persistence.

### Step 1: Define MySQL Secret and ConfigMap

First, we need to create a secret for storing sensitive MySQL information (e.g., user password) and a ConfigMap for less sensitive MySQL configurations (such as user, database name).

**mysql-secret.yaml**:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  mysql-password: <BASE64_ENCODED_PASSWORD>
```

**mysql-configmap.yaml**:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-configmap
data:
  mysql-user: "wordpress"
  mysql-database: "wordpress"
```

You need to replace `<BASE64_ENCODED_PASSWORD>` with the actual base64 encoded password. For example, you can use `echo -n "yourpassword" | base64` in your shell to generate this.

### Step 2: MySQL Deployment and Service

Next, create a deployment for MySQL including a PersistentVolumeClaim.

**mysql-deployment.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.6
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-configmap
              key: mysql-database
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-configmap
              key: mysql-user
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc

---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Step 3: WordPress ConfigMap, Secret and Deployment

Next, configure WordPress with environment-specific ConfigMaps and Secrets.

**wordpress-configmap.yaml**:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-configmap
data:
  wordpress-db-host: "mysql"
  wordpress-db-name: "wordpress"
```

**wordpress-secret.yaml**:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: wordpress-secret
type: Opaque
data:
  wordpress-db-password: <BASE64_ENCODED_PASSWORD>
```

Next, create the WordPress deployment and service.

**wordpress-deployment.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          valueFrom:
            configMapKeyRef:
              name: wordpress-configmap
              key: wordpress-db-host
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-configmap
              key: mysql-user
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: wordpress-secret
              key: wordpress-db-password
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: wordpress-configmap
              key: wordpress-db-name

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Step 4: Applying the Configuration

You will need to apply these configurations to your cluster. Use commands like:
```bash
kubectl apply -f mysql-secret.yaml
kubectl apply -f mysql-configmap.yaml
kubectl apply -f mysql-deployment.yaml
kubectl apply -f wordpress-configmap.yaml
kubectl apply -f wordpress-secret.yaml
kubectl apply -f wordpress-deployment.yaml
```

### Notes
1. Make sure to correctly encode the password and adapt the storage size in the PVC as needed.
2. Please adjust persistent volumes and claims depending on your actual environment demands and capabilities (for instance, storage class in cloud environments).
3. Modify the WordPress and MySQL images and versions as necessary.
