Certainly! Let's break down the setup into several key Kubernetes components and piece together the YAML manifest accordingly. We'll set up ConfigMaps and Secrets for non-sensitive and sensitive configurations respectively, create Deployments for both WordPress and MySQL with PersistentVolumeClaims (PVCs) for MySQL data persistence, and then set up Services to facilitate communication between the components.

### Step 1: Define ConfigMap and Secret

First, let's set up the ConfigMap for MySQL database parameters and a Secret for sensitive credentials.

**1. ConfigMap for MySQL Settings:**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  MYSQL_DATABASE: wordpress_db
```

**2. Secret for MySQL Credentials:**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  mysql_root_password: <base64-encoded-password>
  mysql_user: <base64-encoded-user>
  mysql_password: <base64-encoded-user-password>
```
_Note: Replace `<base64-encoded-password>`, `<base64-encoded-user>`, and `<base64-encoded-user-password>` with your base64 encrypted passwords and usernames._

### Step 2: MySQL Deployment and PersistentVolumeClaim

MySQL containers will need a PVC for persistent data storage.

**MySQL Deployment:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql_root_password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql_user
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql_password
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```

**MySQL PersistentVolumeClaim:**

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Step 3: WordPress Deployment

Next, we need a Deployment for WordPress, which will use environment variables to connect to the configured MySQL instance.

**WordPress Deployment:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql:3306
        - name: WORDPRESS_DB_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql_user
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql_password
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
```

### Step 4: Services for Connectivity

Lastly, services need to be configured to enable connectivity between WordPress and MySQL, and to expose the WordPress instance externally.

**MySQL Service:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  type: ClusterIP
```

**WordPress Service:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Final Note

Be sure to populate the secret values suitably with base64 encoding and deploy everything in the correct order (Secrets and ConfigMaps first, then PVCs, Deployments, and lastly Services) to avoid issues with missing configurations during deployment start up.

This manifests setup should provide a functional WordPress site with MySQL backend, tailored as per Kubernetes best practices for demo or small project scopes. For production environments, consider additional security configurations, resource limitations, monitoring, and logging setups.