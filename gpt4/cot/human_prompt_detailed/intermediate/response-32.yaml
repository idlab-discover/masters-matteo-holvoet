Certainly! To set up WordPress and MySQL on Kubernetes, you will need a series of Kubernetes manifests. Below, I'll provide a comprehensive YAML file that includes all the necessary components: Deployments, Services, PersistentVolumeClaims, a ConfigMap, and a Secret. The setup will be described step-by-step.

### Step 1: Define MySQL Credentials as a Secret

Secrets are used to store sensitive data like database passwords.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
```

Replace `YOUR_BASE64_ENCODED_PASSWORD` with your base64 encoded password. For example, if your password is "mysqlpassword", you can encode it in bash using `echo -n 'mysqlpassword' | base64`.

### Step 2: Create a ConfigMap for MySQL Configuration

ConfigMaps are used to store non-confidential data in key-value pairs.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  MYSQL_DATABASE: wordpress
  MYSQL_USER: wordpress
```

### Step 3: MySQL Deployment and Service

This section includes both the Deployment specification for MySQL and its corresponding service.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_USER
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
```

### Step 4: WordPress Deployment and Service

Similarly, this sets up WordPress to connect to MySQL.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_USER
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Step 5: Deploying and Managing the Application

Deploy these components to your Kubernetes cluster by saving the YAML configurations into files and applying them through `kubectl apply -f <filename>.yaml`. First deploy the secrets and config files, followed by MySQL, and finally WordPress.

```bash
kubectl apply -f secret.yaml
kubectl apply -f configmap.yaml
kubectl apply -f mysql.yaml
kubectl apply -f wordpress.yaml
```

Check on the status of your pods, services, and PersistentVolumeClaims with `kubectl get pods,services,pvc`.

### Conclusion

This basic setup aligns with the requirements, offering a good starting point for running WordPress with a MySQL backend in Kubernetes. Remember to set correct permissions, resource requests and limits, and to manage PersistentVolumes more dynamically depending on the actual environment where you deploy this setup (cloud provider, on-premises, etc.).