Sure! Below is a detailed Kubernetes YAML manifest that will set up a WordPress site with a MySQL backend. The deployment includes ConfigMaps for non-sensitive configuration options, Secrets for sensitive credentials, and PersistentVolumeClaims for data persistence.

First, we need to define the Secret for MySQL credentials, the ConfigMap to store database details, PersistentVolumeClaim for MySQL data persistence, the MySQL Deployment, the Service for MySQL, the ConfigMap for WordPress configuration, and the WordPress Deployment and Service.

Here's the YAML:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  # base64 encoded data (use echo -n 'your-password' | base64 to generate your own)
  MYSQL_ROOT_PASSWORD: eW91ci1yb290LXBhc3N3b3Jk
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-configmap
data:
  MYSQL_DATABASE: wordpress
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.7
        name: mysql
        env:
          - name: MYSQL_ROOT_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: MYSQL_ROOT_PASSWORD
          - name: MYSQL_DATABASE
            valueFrom:
              configMapKeyRef:
                name: mysql-configmap
                key: MYSQL_DATABASE
        ports:
          - containerPort: 3306
        volumeMounts:
          - name: mysql-persistent-storage
            mountPath: /var/lib/mysql
      volumes:
        - name: mysql-persistent-storage
          persistentVolumeClaim:
            claimName: mysql-pv-claim
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-configmap
data:
  WORDPRESS_DB_HOST: mysql:3306
  WORDPRESS_DB_USER: root
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - image: wordpress:latest
        name: wordpress
        ports:
          - containerPort: 80
        env:
          - name: WORDPRESS_DB_HOST
            valueFrom:
              configMapKeyRef:
                name: wordpress-configmap
                key: WORDPRESS_DB_HOST
          - name: WORDPRESS_DB_USER
            valueFrom:
              configMapKeyRef:
                name: wordpress-configmap
                key: WORDPRESS_DB_USER
          - name: WORDPRESS_DB_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: MYSQL_ROOT_PASSWORD
          - name: WORDPRESS_DB_NAME
            valueFrom:
              configMapKeyRef:
                name: mysql-configmap
                key: MYSQL_DATABASE
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30080
  selector:
    app: wordpress
```

In this setup:
- **Secrets** are used to manage the database password securely.
- **ConfigMaps** hold configuration details that aren't sensitive.
- The MySQL deployment mounts volumes using a PersistentVolumeClaim for data persistence to ensure data is not lost on container restarts.
- Services are defined to allow network access to the WordPress instance and MySQL database.

Note: Adjust the `MYSQL_ROOT_PASSWORD` and volumes configurations according to your security and infrastructure requirements. Always base64 encode your secrets before putting them into the manifest.