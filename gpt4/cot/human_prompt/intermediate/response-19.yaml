To deploy a WordPress website with a MySQL database backend in Kubernetes, we typically need several components:

1. A MySQL database deployment
2. A WordPress deployment
3. Persistent Volume Claims (PVCs) for data persistence
4. Services to expose and load balance the deployments

Below is a detailed Kubernetes YAML manifest that accomplishes these requirements. This setup uses basic configurations and should be adapted for production environments (such as configuring secrets for database credentials, using ConfigMaps for configuration files, and possibly customizing security contexts or resource limits).

```yaml
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - image: mysql:5.7
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: yourpassword
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpressuser
        - name: MYSQL_PASSWORD
          value: wordpresspassword
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - image: wordpress:latest
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_NAME
          value: wordpress
        - name: WORDPRESS_DB_USER
          value: wordpressuser
        - name: WORDPRESS_DB_PASSWORD
          value: wordpresspassword
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress
    tier: frontend
```

### Explanation:

- **Persistent Volume Claims (PVCs)**: Two PVCs are declared to persist database and WordPress files across pod restarts.
  
- **MySQL Deployment**: Configured to use a MySQL image. Environment variables are set directly in the YAML (in a production environment, use Kubernetes secrets). A volume is mounted to preserve the data.
  
- **WordPress Deployment**: Uses the latest WordPress image and configures it to communicate with the MySQL service. Environment variables specify database details. A PVC is mounted for storage.

- **Services**: The MySQL service doesn't need an external IP, so `clusterIP: None` is used (Headless service). For WordPress, a LoadBalancer service is used to expose WordPress to external traffic on port 80.

Remember to replace `yourpassword` with more secure passwords; and consider handling these sensitive values with Kubernetes Secrets for a production setup. Additionally, configure readiness and liveness probes and other production-required settings like resource requests and limits based on the expected load.