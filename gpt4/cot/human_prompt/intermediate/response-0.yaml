To deploy a WordPress website with a MySQL backend on Kubernetes, we need to create various resources using YAML manifests. This includes Deployments, Services, PersistentVolumeClaims (for data persistence), and Secrets (for storing sensitive data like passwords). Here's a step-by-step breakdown to set it up.

### Step 1: MySQL Secrets
First, we define a Kubernetes Secret to hold the MySQL password. This method is more secure than straightforward environment variables.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: {{ YOUR_BASE64_ENCODED_PASSWORD }}
```
Replace `{{ YOUR_BASE64_ENCODED_PASSWORD }}` with your actual password encoded in Base64. You can generate a Base64 encoded string using:
```
echo -n 'your-password' | base64
```

### Step 2: MySQL Deployment
Next, set up the MySQL database with a PersistentVolumeClaim to store the database files.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.6
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 3: MySQL Service
Create a Service to allow communication to the MySQL from the WordPress pod.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Step 4: WordPress Deployment
Now, deploy WordPress pointing it to the MySQL Service.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-storage
        persistentVolumeClaim:
          claimName: wp-pv-claim
```

### Step 5: WordPress Service
Finally, expose WordPress with a Service.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

To apply this configuration to your Kubernetes cluster, you need to save these manifests into individual files or as one large file separated by `---`. Use `kubectl apply -f <filename>.yaml` to create the resources on your Kubernetes cluster.

Lastly, be aware that this setup is quite basic and wouldn't be suitable for production without additional security and configuration adjustments such as better password management (e.g., using more robust secret management solutions), scalability configurations, and proper resource limits.