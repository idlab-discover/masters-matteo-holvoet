To deploy a WordPress website using a MySQL database in Kubernetes, you'll require a few components:

1. A MySQL database deployment
2. A WordPress deployment that connects to the MySQL database
3. Persistent Volume Claims (PVCs) for both MySQL and WordPress to ensure data persists
4. A Kubernetes Secret to store the MySQL database credentials securely
5. A service for each deployment to allow network access

### 1. Define a Secret for MySQL Credentials

First, create a Kubernetes Secret object to safely store the MySQL root password and the password that will be used by WordPress to access the database.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  mysql-root-password: cm9vdHBhc3N3b3Jk  # Encoded in Base64
  mysql-password: d3BwYXNzd29yZA==       # Encoded in Base64
```
> **Note**: Replace `cm9vdHBhc3N3b3Jk` and `d3BwYXNzd29yZA==` with your chosen passwords encoded in Base64.

### 2. MySQL Deployment and Service

Next, you need to define a Deployment for MySQL and a persistent volume claim for data storage.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-root-password
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpress
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### 3. WordPress Deployment and Service

Define a Deployment for WordPress and a persistent volume claim for storing WordPress content.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: wordpress
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        - name: WORDPRESS_DB_NAME
          value: wordpress
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wp-pv-claim

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: NodePort
```

This comprehensive setup provides a functional and somewhat resilient WordPress application hosted on Kubernetes, leveraging MySQL as the backend data store. The services expose the necessary ports for communication, and persistent volume claims ensure that the data remains safe across pod restarts. You would need to create or have available a Kubernetes cluster to apply these manifests.