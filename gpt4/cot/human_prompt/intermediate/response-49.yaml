To deploy a WordPress website using a MySQL database on Kubernetes, you'll need two primary components: a MySQL database and a WordPress installation connecting to this database. We'll deploy each within its own Pod, use Kubernetes Services to allow communication between them, and set up Persistent Volumes for data storage to ensure data persists across Pod restarts. I'll provide a basic setup, which you can further configure and extend based on your specific needs.

### Step-by-Step YAML Manifest for MySQL and WordPress with Kubernetes

#### Step 1: MySQL Deployment

1. **PersistentVolumeClaim (PVC) for MySQL** - To store database data:
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

2. **MySQL Deployment**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: yourpassword # Change this password
        - name: MYSQL_DATABASE
          value: wordpress
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

3. **MySQL Service** - To allow communication with WordPress:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

#### Step 2: WordPress Deployment

1. **PersistentVolumeClaim (PVC) for WordPress** - To store WordPress data:
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

2. **WordPress Deployment**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          value: yourpassword # Use the same MySQL root password
        - name: WORDPRESS_DB_NAME
          value: wordpress
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim
```

3. **WordPress Service** - To expose WordPress to the internet or internal network:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Implementing the Configuration
1. Save each block of YAML in its own file or collectively in one file, with `---` separating different documents within the YAML.
2. Apply the YAML using `kubectl apply -f <filename>.yaml`.
3. Verify that all resources are correctly deployed with `kubectl get all`.

This configuration sets up MySQL and WordPress on Kubernetes with persistent storage and exposes WordPress via a LoadBalancer service (you might need to adjust this depending on your cloud provider or local setup). Make sure to adjust the MySQL root password and perhaps add additional environment variables or configurations as per your security and functional requirements.