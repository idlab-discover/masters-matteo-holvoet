Certainly! Deploying a WordPress website backed by a MySQL database in Kubernetes involves creating a few components:

1. **MySQL Deployment**: This will manage the MySQL container instance.
2. **WordPress Deployment**: This manages the WordPress container instance.
3. **Persistent Volumes**: To ensure data persistence across pod restarts and failures.
4. **Secrets**: To securely store database credentials.
5. **Services**: To expose and load balance access to WordPress and allow internal communication with MySQL.

Below I'll walk you through a basic configuration via YAML manifests for each component involved.

### 1. Create a Secret for MySQL Password

We'll start by creating a Kubernetes secret to store the MySQL root password:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: bXlzcWxwYXNz     # Example base64 encoded password (e.g., "mysqlpass")
```

### 2. MySQL Deployment and Service

Next, we'll define the deployment for MySQL. We'll use a PersistentVolume to ensure the data is saved across pod restarts.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### 3. PersistentVolumeClaim for MySQL

Here, we define a PVC for MySQL data:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi
```

### 4. WordPress Deployment and Service

After setting up MySQL, we proceed with WordPress:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### 5. PersistentVolumeClaim for WordPress

Lastly, the PVC for WordPress:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

This set of configurations creates a single-node MySQL and WordPress setup with basic storage and secret management, ready to be adjusted and scaled as needed. Make sure your Kubernetes cluster has the capability to dynamically provision storage, or manually create the necessary Persistent Volumes that fulfill these claims. Remember to apply these configurations using `kubectl apply -f <filename.yaml>` for each file or combined into a single file separated by `---`.