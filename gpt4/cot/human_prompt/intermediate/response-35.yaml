Below, I'll guide you through creating a Kubernetes YAML manifest to deploy a WordPress website using MySQL as the backend, each in their own pods with respective services for connectivity. This will consist of several Kubernetes resources, including Deployments, Persistent Volume Claims, Services, and Secrets.

### Step 1: Define the MySQL Deployment

Let's start by defining a Deployment for MySQL. We'll include a secret to handle the MySQL password.

#### MySQL Secret

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
```

Replace `YOUR_BASE64_ENCODED_PASSWORD` with your desired MySQL password, encoded in Base64. For example, if your password is "mysecretpassword", you can encode it by running:

```bash
echo -n 'mysecretpassword' | base64
```

#### MySQL Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```

#### MySQL PersistentVolumeClaim

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
```

### Step 2: Create a Service for MySQL

This service allows the WordPress pod to communicate with the MySQL database.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Step 3: Define the WordPress Deployment

Now, let's set up WordPress.

#### WordPress Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
```

#### WordPress PersistentVolumeClaim

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

### Step 4: Create a Service for WordPress

This service exposes the WordPress site to the internet.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Usage

1. First, replace `YOUR_BASE64_ENCODED_PASSWORD` with your actual base64-encoded MySQL password.
2. Apply these configurations using `kubectl apply -f <filename>.yaml`.

This setup provides a basic, but functional WordPress site using MySQL, with each having persistent storage and proper secrets management. For production use, you might consider additional security and performance optimizations.