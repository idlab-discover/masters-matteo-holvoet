Creating a Kubernetes YAML manifest to deploy a WordPress website with a MySQL database involves several components: Persistent Volume Claims (PVCs) for data persistence, Deployments for managing the WordPress and MySQL pods, and Services to expose and load-balance the applications. 

Here's a step-by-step explanation with the YAML manifest detailing each component:

### Step 1: Persistent Volume Claims (PVCs)

Persistent Volume Claims are used to request storage which will be used to persist data even when pods are restarted or destroyed. Both MySQL and WordPress need persistent storage.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Step 2: MySQL Deployment

This deployment will manage the MySQL container instance. It uses the PVC created above and defines environment variables for the MySQL root password and other database configurations.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
        - image: mysql:5.7
          name: mysql
          env:
            - name: MYSQL_ROOT_PASSWORD
              value: yourpassword # Please use a secret for storing passwords
            - name: MYSQL_DATABASE
              value: wordpress
          ports:
            - containerPort: 3306
              name: mysql
          volumeMounts:
            - name: mysql-persistent-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-persistent-storage
          persistentVolumeClaim:
            claimName: mysql-pv-claim
```

### Step 3: WordPress Deployment

This deployment manages the WordPress instance, connecting it to the MySQL database through environment variables. It also uses the corresponding PVC.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
        - image: wordpress:latest
          name: wordpress
          env:
            - name: WORDPRESS_DB_HOST
              value: mysql
            - name: WORDPRESS_DB_USER
              value: root
            - name: WORDPRESS_DB_PASSWORD
              value: yourpassword # Again, kindly use a secret for this
            - name: WORDPRESS_DB_NAME
              value: wordpress
          ports:
            - containerPort: 80
              name: wordpress
          volumeMounts:
            - name: wordpress-persistent-storage
              mountPath: /var/www/html
      volumes:
        - name: wordpress-persistent-storage
          persistentVolumeClaim:
            claimName: wordpress-pv-claim
```

### Step 4: Services

We need to expose both MySQL and WordPress via services. MySQL will use a ClusterIP service (only accessible within the cluster), whereas WordPress will use a LoadBalancer service to be accessible from the outside.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
    - port: 80
      targetPort: 80
  selector:
    app: wordpress
    tier: frontend
  type: LoadBalancer
```

This configuration should be functional on a Kubernetes cluster that provides dynamic volume provisioning and a cloud provider with LoadBalancer support. Adjust storage sizes and versions as per your specific requirements. Ensure you replace sensitive information like passwords with Kubernetes Secrets before deploying this configuration in a production environment.