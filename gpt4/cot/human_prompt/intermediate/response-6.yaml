To deploy a WordPress website using a MySQL database on Kubernetes, you would typically use two Deployments along with their respective Services. Below, I'll walk you through a step-by-step creation of the necessary Kubernetes YAML manifests.

### Step 1: Define the MySQL Deployment

This deployment will manage the MySQL database container. We'll use an environment file or explicit environment variables to configure the MySQL database credentials (username, password, and database name).

Here's a simple example of a MySQL deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: yourpassword
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpressuser
        - name: MYSQL_PASSWORD
          value: wordpresspassword
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```

### Step 2: Define the MySQL Service

This service exposes the MySQL database to other pods (namely the WordPress pod) inside the cluster.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None  # This makes it a headless service.
```

### Step 3: Define the WordPress Deployment

This deployment will manage the WordPress container. It will need to connect to the MySQL database service configured earlier.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: wordpressuser
        - name: WORDPRESS_DB_PASSWORD
          value: wordpresspassword
        - name: WORDPRESS_DB_NAME
          value: wordpress
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
```

### Step 4: Define the WordPress Service

This service will expose the WordPress frontend to the network outside the Kubernetes cluster.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
    tier: frontend
  type: LoadBalancer
```

### Additional Considerations
- **Persistent Volumes**: You will need to define PersistentVolumeClaims (`mysql-pvc` and `wordpress-pvc`) to handle data persistency.
- **Security and Secret Management**: Itâ€™s best practice to use Kubernetes Secrets to manage sensitive data like database passwords.
- **Scaling and Resource Limits**: Depending on your production needs, you may want to configure CPU/memory resources and set up horizontal pod autoscaling.

With these components in place, you can proceed to create each of these resources in your Kubernetes cluster using `kubectl apply -f <filename>.yaml`. This basic setup provides a functional WordPress site with a MySQL backend, appropriate for both developmental and small-scale production environments.