To deploy a WordPress website with a MySQL database on Kubernetes, you will need several components including a PersistentVolume (if not using dynamic provisioning through PersistentVolumeClaims), a Deployment for WordPress, a Deployment for MySQL, Services for both deployments, and secrets or config maps to manage configurations such as password storage. Below, I've outlined a step-by-step construction of the necessary Kubernetes YAML manifest.

### 1. Define a Namespace (Optional but recommended)
Let's start by creating a namespace to isolate our project components.

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress-namespace
```

### 2. Create a Secret for MySQL Credentials
Passwords and other sensitive data should be stored in Kubernetes secrets.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  namespace: wordpress-namespace
type: Opaque
data:
  password: <base64-encoded-password>
```
**Note**: Replace `<base64-encoded-password>` with your actual base64 encoded password.

### 3. MySQL Deployment
This deployment will handle the MySQL container.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```

### 4. MySQL Service
This service exposes the MySQL deployment within the cluster.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress-namespace
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None # Uses a headless service for stateful applications
```

### 5. PersistentVolumeClaim for MySQL
This YAML sets up persisting data storage for MySQL.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: wordpress-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### 6. WordPress Deployment
This deploys WordPress linked to the MySQL Service.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
```

### 7. WordPress Service
This service makes the WordPress deployment accessible via a stable endpoint.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress-namespace
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### 8. PersistentVolumeClaim for WordPress
This is for WordPress storage.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pvc
  namespace: wordpress-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

These are the basic components required for setting up WordPress with a MySQL backend on Kubernetes. Note, the configuration must be tailored to match specific requirements and the environment where Kubernetes is running (e.g., cloud provider specifics like storage class). Adjust parameters like resource requests based on anticipated load and capacity requirements.