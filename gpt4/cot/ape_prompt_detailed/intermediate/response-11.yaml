Creating a Kubernetes YAML manifest file for deploying a WordPress website with a MySQL backend involves several components. We'll break it down into the following parts:
1. ConfigMap for MySQL and WordPress configurations.
2. Secret for sensitive information such as database passwords.
3. Persistent Volume Claim for MySQL storage.
4. Deployments for MySQL and WordPress.
5. Services for MySQL and WordPress to enable network connectivity.

Letâ€™s define each of these components in YAML format.

### Step 1: ConfigMap
First, we create a ConfigMap to store non-sensitive configuration options, like MySQL's user and database name.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-wordpress-config
data:
  # Configuration values can be parameterized
  database-name: wordpress
  database-user: wordpress
```

### Step 2: Secret
Next, we create a Secret to securely store sensitive information, such as passwords.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-wordpress-secret
type: Opaque
data:
  # Base64 encoded
  database-password: cGFzc3dvcmQ= # "password" as an example
```

### Step 3: PersistentVolumeClaim
We define a PersistentVolumeClaim for MySQL data persistence.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### Step 4: Deployments
#### MySQL Deployment
This deployment utilizes the Secret and PersistentVolumeClaim.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-wordpress-config
              key: database-name
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-wordpress-config
              key: database-user
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-wordpress-secret
              key: database-password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

#### WordPress Deployment
This deployment utilizes the ConfigMap and Secret, and connects to the MySQL service.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: mysql-wordpress-config
              key: database-name
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-wordpress-config
              key: database-user
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-wordpress-secret
              key: database-password
        ports:
        - containerPort: 80
```

### Step 5: Services
#### MySQL Service
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

#### WordPress Service
```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

This completes the Kubernetes manifest file setup to deploy a WordPress site with a MySQL backend, including using ConfigMaps and Secrets for configuration management and sensitive data. Remember to replace the `data.database-password` field with a real base64-encoded password for production environments.