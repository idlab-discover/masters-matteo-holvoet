To fulfill your request, I’ll help you break down the task and write a Kubernetes YAML manifest step-by-step for deploying a WordPress website with a MySQL backend. This setup will include Deployments, Services, ConfigMaps, Secrets, and PersistentVolumeClaims. 

### Step 1: Define ConfigMap for MySQL Configuration

Let's start by creating a ConfigMap for the MySQL configuration.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  MYSQL_DATABASE: wordpress
  MYSQL_USER: wpuser
```

### Step 2: Define Secret for Sensitive Data

Next, let’s define a Secret to securely store sensitive data such as the MySQL root password and the user password.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  MYSQL_ROOT_PASSWORD: <<base64 encoded password>>
  MYSQL_PASSWORD: <<base64 encoded password>>
```
**Replace `<<base64 encoded password>>` with the actual base64-encoded passwords.**

### Step 3: MySQL Deployment and PersistentVolumeClaim

Now, create a Deployment for MySQL, along with a PersistentVolumeClaim to ensure data persistence.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_ROOT_PASSWORD
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_USER
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_PASSWORD
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### Step 4: MySQL Service

Create a Service for MySQL to allow communication between it and the WordPress service.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Step 5: WordPress Deployment

Now, we create the Deployment for WordPress.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_USER
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_PASSWORD
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
```

### Step 6: WordPress Service

Finally, let’s create a Service for WordPress.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Conclusion

This setup should give you a basic deployment of WordPress and MySQL with data persistence and configuration managed through ConfigMaps and Secrets. You can adjust storage sizes, version pinning, scaling properties, and other configurations as necessary for production environments.