Certainly! To create a Kubernetes manifest that deploys a WordPress site with a MySQL backend, you'll need to create several resource definitions including Deployments, Services, a ConfigMap, a Secret, and PersistentVolumeClaims. Below is a detailed YAML manifest crafted according to your specifications:

### Step 1: Create the MySQL Secret for storing sensitive data

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
```
Replace `YOUR_BASE64_ENCODED_PASSWORD` with your actual MySQL password encoded in Base64 format.

### Step 2: Create the ConfigMap for MySQL and WordPress configuration

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-wordpress-config
data:
  # MySQL configurations
  MYSQL_DATABASE: wordpress
  MYSQL_USER: wordpress
  # WordPress configurations
  WORDPRESS_DB_HOST: mysql:3306
  WORDPRESS_DB_NAME: wordpress
  WORDPRESS_DB_USER: wordpress
```

### Step 3: Create PersistentVolumeClaim for MySQL data storage

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### Step 4: Create MySQL Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
          - name: MYSQL_ROOT_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-pass
                key: password
          - name: MYSQL_DATABASE
            valueFrom:
              configMapKeyRef:
                name: mysql-wordpress-config
                key: MYSQL_DATABASE
          - name: MYSQL_USER
            valueFrom:
              configMapKeyRef:
                name: mysql-wordpress-config
                key: MYSQL_USER
          - name: MYSQL_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-pass
                key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 5: Create WordPress Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
          - name: WORDPRESS_DB_HOST
            valueFrom:
              configMapKeyRef:
                name: mysql-wordpress-config
                key: WORDPRESS_DB_HOST
          - name: WORDPRESS_DB_USER
            valueFrom:
              configMapKeyRef:
                name: mysql-wordpress-config
                key: WORDPRESS_DB_USER
          - name: WORDPRESS_DB_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-pass
                key: password
          - name: WORDPRESS_DB_NAME
            valueFrom:
              configMapKeyRef:
                name: mysql-wordpress-config
                key: WORDPRESS_DB_NAME
        ports:
        - containerPort: 80
```

### Step 6: Create Services for MySQL and WordPress

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Assembling the Manifest

To deploy this setup in Kubernetes, you should save the entire configuration into a single YAML file (e.g., `wordpress-mysql-deployment.yaml`) and then apply it using `kubectl`.

```sh
kubectl apply -f wordpress-mysql-deployment.yaml
```

This series of resources will fully configure both WordPress and MySQL, storing sensitive data in Secrets, other configurations in ConfigMaps, and ensuring that data persistence is managed through PersistentVolumeClaims. Note that you need a Kubernetes cluster with a storage class supporting dynamic provisioning to support the PersistentVolumeClaim properly. The WordPress service is exposed on a LoadBalancer, which will differ depending on your Kubernetes environment (cloud, on-prem, etc.).