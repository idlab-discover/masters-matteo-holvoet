Sure, let's create a Kubernetes YAML manifest to set up a WordPress website with a MySQL database, using ConfigMaps, Secrets, Deployments, PersistentVolumeClaims (PVCs), and Services.

### Step 1: Secret for MySQL Database Credentials

First, we'll store the MySQL database credentials in a Kubernetes Secret. This ensures that sensitive information like the database password is not exposed in plaintext in our configuration files.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  password: <base64-encoded-password>
```

You need to replace `<base64-encoded-password>` with your actual base64-encoded password. You can generate this by running:

```bash
echo -n 'yourpassword' | base64
```

### Step 2: ConfigMap for MySQL and WordPress Configuration

Next, we create a ConfigMap which can be used to configure our MySQL and WordPress deployments.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wp-mysql-config
data:
  MYSQL_DATABASE: wordpress
  MYSQL_USER: wordpress
```

### Step 3: PersistentVolumeClaim for MySQL Persistence

We'll define a PVC to ensure that the MySQL data is persisted across pod restarts and failures.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### Step 4: Deployments for MySQL and WordPress

Here, we set up two Deployments, one for MySQL and another for WordPress, utilizing the ConfigMap and Secret.

#### MySQL Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-pass
                  key: password
            - name: MYSQL_DATABASE
              valueFrom:
                configMapKeyRef:
                  name: wp-mysql-config
                  key: MYSQL_DATABASE
            - name: MYSQL_USER
              valueFrom:
                configMapKeyRef:
                  name: wp-mysql-config
                  key: MYSQL_USER
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mysql-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-storage
          persistentVolumeClaim:
            claimName: mysql-pv-claim
```

#### WordPress Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
        - name: wordpress
          image: wordpress:latest
          env:
            - name: WORDPRESS_DB_HOST
              value: mysql
            - name: WORDPRESS_DB_USER
              valueFrom:
                configMapKeyRef:
                  name: wp-mysql-config
                  key: MYSQL_USER
            - name: WORDPRESS_DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-pass
                  key: password
            - name: WORDPRESS_DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: wp-mysql-config
                  key: MYSQL_DATABASE
          ports:
            - containerPort: 80
```

### Step 5: Services for MySQL and WordPress

Finally, define services for both MySQL and WordPress to expose the deployments within the cluster and, optionally, externally for the WordPress service.

#### MySQL Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

#### WordPress Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

This complete manifest incorporates best practices such as using Secrets for sensitive information, ConfigMaps for configuration, and persistent storage for MySQL. You can adjust storage sizes and other specifics according to your needs.