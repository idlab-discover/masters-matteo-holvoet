```yaml
# MySQL Deployment with PersistentVolumeClaim
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
          - name: MYSQL_ROOT_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: root-password
          - name: MYSQL_DATABASE
            valueFrom:
              configMapKeyRef:
                name: mysql-configmap
                key: database
          - name: MYSQL_USER
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: user
          - name: MYSQL_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim

---
# MySQL PersistentVolumeClaim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
# WordPress Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
          - name: WORDPRESS_DB_HOST
            value: mysql
          - name: WORDPRESS_DB_USER
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: user
          - name: WORDPRESS_DB_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: password
          - name: WORDPRESS_DB_NAME
            valueFrom:
              configMapKeyRef:
                name: mysql-configmap
                key: database
        ports:
        - containerPort: 80

---
# Services for MySQL and WordPress
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  type: ClusterIP
  ports:
  - port: 3306
  selector:
    app: mysql

---
# ConfigMap for MySQL database
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-configmap
data:
  database: wordpress_db

---
# Secrets for MySQL
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  root-password: [base64-encoded-value]
  user: [base64-encoded-value]
  password: [base64-encoded-value]

```

### Explanation and Rationale Behind Choices:

1. **Container Naming**:
   - Naming containers like 'wordpress' and 'mysql' simplifies service discovery within Kubernetes. Each pod can reach another using simple DNS names based on the service that fronts the pods. It has a direct impact on maintainability and clarity of Kubernetes configurations.

2. **Security and Image Selection**:
   - Utilizing an official image (`mysql:5.7` and `wordpress:latest`) leverages trusted sources known for stability and performance. It is crucial to use official or well-vetted images to mitigate security risks.

3. **Persistent Storage**:
   - The `PersistentVolumeClaim` for MySQL ensures that data persists across pod restarts and failures. Selecting the appropriate storage type (e.g., SSD for higher IOPS) depends on use case requirements and budget.

4. **Services**:
   - A `LoadBalancer` service for WordPress allows for external access, essential for a web application, while `ClusterIP` for MySQL restricts database access within the cluster, enhancing security.

5. **Configuration and Secrets**:
   - Separating sensitive data into Kubernetes secrets and other configurations into ConfigMaps ensures that sensitive data like passwords are handled securely and segregated from non-sensitive configuration data. Kubernetes encrypts secrets at rest.

6. **Scalability and Fault Tolerance**:
   - While not explicitly included in the YAML, setting up Horizontal Pod Autoscaler (HPA) based on metrics (CPU, requests) for WordPress can help in scaling the application based on demand and ensure availability during high traffic periods.

This blueprint provides a robust foundation for deploying a secure and resilient WordPress application backed by MySQL, emphasizing best practices and strategic decision-making tailored for real-world applications.