Here's an example Kubernetes YAML configuration that addresses the detailed requirements from your prompt:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress-mysql

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
  namespace: wordpress-mysql
data:
  WORDPRESS_DB_HOST: mysql:3306
  WORDPRESS_DB_NAME: wordpress

---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
  namespace: wordpress-mysql
type: Opaque
data:
  MYSQL_ROOT_PASSWORD: <encoded-root-password>
  MYSQL_PASSWORD: <encoded-password>

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  namespace: wordpress-mysql
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: standard

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress-mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_ROOT_PASSWORD
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_NAME
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress-mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress-mysql
spec:
  replicas: 2
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:5.1.1-php7.3-apache
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_HOST
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_NAME
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_PASSWORD

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress-mysql
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress

---
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress-hpa
  namespace: wordpress-mysql
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50
```

This configuration includes a namespace for logical separation, uses ConfigMaps and Secrets for configuration and sensitive information management, provisions for persistent storage with PVCs, sets up deployments and services for both WordPress and MySQL, and incorporates an HPA (Horizontal Pod Autoscaler) for responding to changes in load.

Remember to replace `<encoded-root-password>` and `<encoded-password>` with your base64-encoded passwords. This example assumes your Kubernetes cluster is configured with a default storage class that supports dynamic provisioning, and a LoadBalancer provider is configured for exposing WordPress externally. Adjust according to your actual environment and considerations for resilience, security, and scalability as needed.