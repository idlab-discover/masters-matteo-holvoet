Here's a detailed Kubernetes manifest according to the requirements specified for deploying a WordPress website with a MySQL backend, including considerations for data persistence, security, scalability, and network policy.

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress-namespace
---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  namespace: wordpress-namespace
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
  namespace: wordpress-namespace
data:
  database: wordpress
  user: wp_user
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
  namespace: wordpress-namespace
data:
  wp_user: wp_user
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  namespace: wordpress-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress-namespace
  labels:
    app: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.7
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: database
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: user
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress-namespace
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress-namespace
  labels:
    app: wordpress
spec:
  replicas: 2
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - image: wordpress:latest
        name: wordpress-container
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: wp_user
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
          name: wordpress
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress-namespace
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress
---
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress-hpa
  namespace: wordpress-namespace
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
```

1. **Namespace**: Isolated environment within the cluster to avoid collision with names in other environments.
2. **Secrets and ConfigMaps**: Used to efficiently manage configurations and sensitive data.
3. **PersistentVolumeClaim (PVC)**: Ensures data persists across pod restarts.
4. **Deployments**: Separate for MySQL and WordPress using best practices for labels and software version control.
5. **Services**: Network access setups for both MySQL (cluster internal) and WordPress (with external LoadBalancer).
6. **HorizontalPodAutoscaler**: Automatically scales WordPress up to handle load.

**Alternative MySQL Deployments**: One alternative could be using a StatefulSet for MySQL, which ensures ordered, graceful deployment and scaling and stable, unique network identifiers. This might be preferred in scenarios where stable, persistent identifiers for each MySQL instance are necessary, for example, in more complex cluster setups. 

**Caching Opportunities**: Introducing a caching layer with technologies like Redis or Memcached could improve WordPress performance. Caching could reduce the load on the database, which is crucial during high traffic periods, but it introduces complexity in terms of managing another layer of state which needs synchronization and potentially more complexity in the deployment and operation phases.