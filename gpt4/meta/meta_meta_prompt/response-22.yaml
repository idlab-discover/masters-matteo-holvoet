Here is the Kubernetes YAML manifest based on the requirements provided:

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
  namespace: wordpress
spec:
  serviceName: mysql
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: yourpassword
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
        readinessProbe:
          tcpSocket:
            port: 3306
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress
spec:
  ports:
  - port: 3306
  clusterIP: None
  selector:
    app: mysql

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pvc
  namespace: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress
spec:
  replicas: 3
  selector:
    matchLabels:
      app: wordpress
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql.wordpress.svc.cluster.local
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          value: yourpassword
        - name: WORDPRESS_DB_NAME
          value: wordpress
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-storage
          mountPath: /var/www/html
        readinessProbe:
          httpGet:
            path: /wp-admin/install.php
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: wordpress-storage
        persistentVolumeClaim:
          claimName: wp-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Considerations and Trade-offs:
1. **Session Consistency**: Wordpress state is stored in a centralized MySQL database, ensuring session consistency as the WordPress pods are stateless. To keep data up-to-date across replicas in MySQL, this solution uses a StatefulSet to manage the databases. Pods communicate effectively through ClusterIP services ensuring consistent data among services. 

2. **Handling Traffic Spikes**: The deployment strategy with `RollingUpdate` allows for smooth scaling without downtime. If traffic spikes, Kubernetes Horizontal Pod Autoscaler (not included here) can be attached to automatically scale the WordPress pods based on CPU and memory usage metrics.

3. **Database Failures**: The MySQL setup with multiple replicas ensures that if one database instance fails, the others can still handle requests ensuring high availability. The persistent volume ensures data persistence across pod restarts. Regular backups and monitoring can further mitigate risks.

4. **Monitoring**: Integration with monitoring tools such as Prometheus for capturing metrics and Grafana for dashboards to observe CPU usage, memory consumption, response times, and system health would be crucial. Alerts can be configured for anomalies.

5. **Cost-Performance-Complexity**: Multiple replicas and persistent storages increase the cost but enhance performance and reliability. The complexity of setting up and maintaining a multi-replica database with consistent backups and efficient scaling can pose challenges. Clear documentation, consistent testing, and employing experienced Kubernetes administrators can mitigate these issues.

This setup assumes Kubernetes operators or administrators have configured the essential storage class, persistent volume, and networking policies to support such deployments. Adjustments for specific cloud environments or specific configurations may be necessary.