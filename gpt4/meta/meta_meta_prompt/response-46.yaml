```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress-deployment
---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  namespace: wordpress-deployment
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress-deployment
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress-deployment
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 10
          timeoutSeconds: 5
        livenessProbe:
          httpGet:
            path: /wp-admin/install.php
            port: 80
          initialDelaySeconds: 15
          timeoutSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress-deployment
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
---
apiVersion: autoscaling/v2beta1
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress-hpa
  namespace: wordpress-deployment
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      targetAverageUtilization: 50
```

### Justification for Design Decisions

**1. Autoscaling Configuration:**
   - A HorizontalPodAutoscaler is implemented for the WordPress deployment to handle sudden spikes in traffic. I set minimum replicas to 2 for initial fault tolerance and up to 10 replicas to maintain availability during peak loads. CPU utilization is targeted at 50%, which is efficient in both resource usage and response times. An alternative would be to scale based on memory, but CPU is often the first metric affected by increased web traffic.

**2. Security Practices:**
   - Password for MySQL is stored in a Secret to avoid plain text credentials within Pod configurations. Using a Recreate deployment strategy for MySQL mitigates risks in situations where data consistency is key.
   - For further securing, we could add security contexts to each pod configuration to limit user privileges but this was omitted for simplicity.
   - Network policies could also isolate traffic within the cluster but aren't included here for brevity.

**3. Management of Schema Changes:**
   - The deployment uses versioned MySQL images and a strategy that avoids downtime by utilizing Kubernetes' inherent rolling update mechanism. For direct schema management, one would ideally integrate jobs to handle migrations during deployment, perhaps managed by CI/CD pipelines. Tools like Flyway or Liquibase could help version control the database schema.
   - Backing up databases before performing schema updates is crucial and can be managed through Kubernetes cron jobs for automated backups.

**Overall,** this configuration offers a robust method to deploy a WordPress site with MySQL backend on Kubernetes, handling scale and security effectively, while providing a foundation for efficient schema evolution management techniques.