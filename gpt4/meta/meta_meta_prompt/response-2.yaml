Below is the Kubernetes YAML manifest that sets up a high-availability WordPress website with a MySQL backend, using best practices for data persistence, secure credential management, multi-zone resilience, and scalability considerations:

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress-deployment
---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  namespace: wordpress-deployment
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
  namespace: wordpress-deployment
data:
  WORDPRESS_DB_HOST: mysql
  WORDPRESS_DB_USER: wordpress
  WORDPRESS_DB_PASSWORD: placeholder
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  namespace: wordpress-deployment
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress-deployment
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
  namespace: wordpress-deployment
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: "app"
                    operator: In
                    values:
                    - wordpress
              topologyKey: "kubernetes.io/hostname"
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_HOST
        - name: WORDPRESS_DB_USER
          value: wordpress
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_PASSWORD
        ports:
        - containerPort: 80
        volumeMounts:
        - name: wordpress-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress-deployment
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress-deployment
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Explanation of the Manifest
1. **High Availability & Load Distribution**: We used a 3-replica deployment for the WordPress pods spread across different nodes (using pod anti-affinity) to ensure that the service remains available even if a node goes down. `LoadBalancer` type service is used to distribute traffic among the pods.

2. **Persistent Data Storage**: `PersistentVolumeClaim` (PVCs) are used for both MySQL and WordPress to ensure data persistence across pod restarts and crashes.

3. **Security**: Database credentials are managed using Kubernetes Secrets and are only exposed to the MySQL and WordPress pods through environment variables. Communication between WordPress and MySQL uses internal service names, limiting access from outside the cluster.

4. **Scalability**: The setup is initially scalable to handle increased traffic based on the `replicas` setting for the WordPress deployment. Horizontal scalability can be further managed dynamically through the implementation of a Horizontal Pod Autoscaler based on CPU or memory usage.

5. **Multi-zone Deployment Strategy**: Although not explicitly set in the YAML, this setup should be deployed across multiple zones, offering resilience against zone failures. The scheduler's automatic spread across availability zones (if configured in the cluster) and the use of multi-AZ persistent storage would enhance durability and availability.

### Further Considerations
- **Monitoring and Logs**: Integration with monitoring tools like Prometheus and fluentd for log management would be valuable for maintaining the health of the application.
- **Resource Limits and Requests**: Proper CPU and memory requests and limits should be set for each pod to ensure efficient scheduling and resource allocation.
- **Backup and Recovery**: Regular backups of the WordPress database should be scheduled and tested.

These YAML configurations and strategic decisions provide a template for deploying a resilient, secure, and scalable WordPress site on Kubernetes.