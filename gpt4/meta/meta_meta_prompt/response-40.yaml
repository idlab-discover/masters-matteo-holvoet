```yaml
# Kubernetes manifest for a scalable WordPress website with MySQL database backend

---
# Namespace for the WordPress and MySQL deployment
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress-deployment

---
# PersistentVolumeClaim for MySQL Database
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  namespace: wordpress-deployment
  labels:
    app: mysql
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
# MySQL Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress-deployment
spec:
  replicas: 2  # High-availability setup with 2 replicas
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
          - name: MYSQL_ROOT_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysql-secret
                key: password
          - name: MYSQL_DATABASE
            value: wordpressdb
        ports:
        - containerPort: 3306
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim

---
# MySQL Service to expose MySQL to WordPress
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress-deployment
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None  # Headless service for stable network identity

---
# Secret for storing sensitive MySQL credentials
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
  namespace: wordpress-deployment
type: Opaque
data:
  password: QUxhZGRpbjpPcGVuU2VzYW1l  # Base64 encoded password

---
# PersistentVolumeClaim for WordPress
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
  namespace: wordpress-deployment
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

---
# WordPress Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress-deployment
spec:
  replicas: 3  # Scalability with 3 replicas
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: password
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "512Mi"
            cpu: "300m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim

---
# WordPress Service to expose WordPress to external traffic
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress-deployment
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress
```

### Explanation and Evaluation:

1. **High Availability and Load Balancing**: The MySQL deployment uses two replicas, ensuring that if one pod fails, another can take over, minimizing downtime. A headless service for MySQL aids in consistent internal discovery. For WordPress, three replicas are used to handle increased loads and traffic spikes. A LoadBalancer service type for WordPress distributes external traffic across these instances.

2. **Secure Communication**: Sensitive information like the MySQL password is stored in a Kubernetes Secret and accessed via environment variables. This addresses security of sensitive data at rest through Secrets (encrypted at storage level) and in transit via internal cluster communication safeguards.

3. **Resource Management**: Initial resource requests and limits for both WordPress and MySQL are based on expected typical use cases. These settings prevent resource starvation and ensure QoS by allowing scaling based on load.

4. **Backup Strategy**: While not explicitly detailed in YAML, a robust strategy would include regular database dumps through Kubernetes cron jobs, storing backups in a separate PersistentVolume or external storage, ensuring data integrity and facilitating quick recovery with minimal downtime.

### Adaptation for Various Scenarios:
- **Sudden Increase in Web Traffic**: Auto-scaling can be enabled for WordPress pods with Horizontal Pod Autoscalers reacting to CPU/memory thresholds.
- **Multi-cloud Deployment**: Use of a container-native storage solution that supports multi-cloud setups can help in handling data consistency across different cloud environments.

These configurations optimize for a typical mid-tier deployment and would need calibration based on actual performance metrics and specific use cases.