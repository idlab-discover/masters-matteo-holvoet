```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress
---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  namespace: wordpress
type: Opaque
data:
  password: YOUR_BASE64_ENCODED_PASSWORD
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  namespace: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
  namespace: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  strategy: 
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1"
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress
spec:
  replicas: 5
  selector:
    matchLabels:
      app: wordpress
  strategy: 
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "512Mi"
            cpu: "300m"
          limits:
            memory: "1Gi"
            cpu: "1"
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Explanation of the Manifests Design and Decisions

1. **Scalability and Load Management:**
   - **MySQL Deployment:** Set to 3 replicas for high availability. This setup allows for failover in case one instance fails.
   - **WordPress Deployment:** Initially configured with 5 replicas to handle increased web traffic. Both deployments use a `RollingUpdate` strategy for zero downtime during updates.
   
2. **Security Considerations:**
   - **Secret Management:** MySQL password is stored in Kubernetes secrets and accessed using environment variables, ensuring that sensitive data isn't exposed in the deployment scripts.
   - **Network Policies:** (Not shown here but recommended) Restricting which pods can communicate with each other can further secure the environment.

3. **Resource Optimization:**
   - **Resource Requests and Limits:** Set for both MySQL and WordPress containers. These values are chosen to prevent overallocation while still providing enough resources under load. These settings are crucial for controlling the resource utilization across the cluster, helping in cost reduction while maintaining performance.

4. **Challenging Convention:**
   - This deployment is straightforward and typical. An innovative approach could include using a managed SQL service or integrating caching layers like Redis to enhance performance.

5. **Failure Scenarios and Recovery:**
   - The use of persistent volumes ensures data durability beyond pod lifecycle. In a true production setup, it's also wise to consider off-cluster backups and more sophisticated disaster recovery strategies.

This configuration forms a strong foundation for a resilient, scalable WordPress site on Kubernetes, with considerations for security and efficiency. Adjustments in resource allocation should be made based on application-specific metrics and performance indicators.
