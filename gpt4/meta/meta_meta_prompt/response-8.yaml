```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: wordpress-namespace
---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  namespace: wordpress-namespace
type: Opaque
data:
  password: encoded-password-here  # base64 encoded password

---
# MySQL Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: wordpress-namespace
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim

---
# MySQL Service
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: wordpress-namespace
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
  clusterIP: None

---
# WordPress Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  namespace: wordpress-namespace
spec:
  replicas: 3
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        resources:
          requests:
            memory: "512Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim

---
# WordPress Service
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  namespace: wordpress-namespace
spec:
  ports:
  - port: 80
  selector:
    app: wordpress
  type: LoadBalancer

---
# PersistentVolumeClaims
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  namespace: wordpress-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
  namespace: wordpress-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

---
# Network Policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: wordpress-network-policy
  namespace: wordpress-namespace
spec:
  podSelector:
    matchLabels:
      app: wordpress
  ingress:
    - from:
      - podSelector:
          matchLabels:
            app: mysql
  egress:
    - to:
      - podSelector:
          matchLabels:
            app: mysql

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: mysql-network-policy
  namespace: wordpress-namespace
spec:
  podSelector:
    matchLabels:
      app: mysql
  ingress:
    - from:
      - podSelector:
          matchLabels:
            app: wordpress
```

This configuration addresses security, resource management, scalability, upgrade path, and evaluation metrics considerations:
1. **Security Optimization:** Utilizes Kubernetes Secrets to manage sensitive data and Network Policies to restrict traffic flow.
2. **Resource Constraints:** Sets limits and requests for CPU and memory to manage resource allocation efficiently.
3. **Scalability Challenge:** WordPress deployment is set to three replicas, scalable as needed. MySQL uses a persistent volume with a single replica, suitable for starting scenarios, but consider StatefulSet or clustering solutions for production environments.
4. **Maintenance and Upgrade Path:** The strategy field in MySQL Deployment ensures data integrity during upgrades by preventing multiple instances from running simultaneously.
5. **Evaluation Metrics:** Would typically involve metrics like CPU and memory utilization, response times, and error rates to monitor system health, especially when scaling dynamically.
These configurations enhance system resilience, efficiency, and security, making the setup more robust and scalable.