To deploy a robust WordPress site on Kubernetes with a MySQL database backend, the following detailed plan addresses each key area from scaling to security and network policies. This plan will utilize Kubernetes resources like Deployments, StatefulSets, Persistent Volumes, Horizontal Pod Autoscalers, Secrets, and Network Policies.

### 1. Scale and Load Balancing

For scaling and load balancing, we'll use a Deployment for the WordPress application with a replicable setup, and employ a Horizontal Pod Autoscaler (HPA) to dynamically adjust the number of pods according to CPU and memory usage. A LoadBalancer type Service will route external traffic efficiently to the WordPress pods.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  replicas: 3
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 100m
            memory: 200Mi
          limits:
            cpu: 500m
            memory: 500Mi

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress

---
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50
  targetMemoryUtilizationPercentage: 50
```

### 2. Data Persistence

For MySQL, we'll use a StatefulSet to ensure pod identity and stable, persistence storage using a Persistent Volume Claim (PVC). This setup allows for data recovery and consistent storage even if a pod fails.

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: "mysql"
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-root-password
              key: password
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

### 3. Security and Secret Management

Sensitive data like the MySQL root password is stored in a Kubernetes Secret. This approach secures sensitive information at rest and restricts access to the data via RBAC (Role-Based Access Control).

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-root-password
type: Opaque
data:
  password: <base64-encoded-password>
```

### 4. Network Policies

Network policies restrict communication between WordPress and MySQL to only necessary traffic, enhancing security against potential internal threats.

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: wordpress-mysql-policy
spec:
  podSelector:
    matchLabels:
      app: wordpress
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: mysql
    ports:
    - protocol: TCP
      port: 3306
```

### 5. Resource Limits and Requests

As already demonstrated in the WordPress and MySQL container specifications, setting CPU and memory requests and limits helps ensure efficient resource utilization and prevents resource starvation.

These meticulously crafted manifests not only address each challenge posed in the scenario but also leverage Kubernetes' features to create a highly available, secure, and efficient WordPress deployment.