Certainly! Deploying a WordPress site with a MySQL backend in Kubernetes requires creating several resources. Here is a step-by-step guide, including ConfigMaps or Secrets for sensitive data, Services, Deployments, and PersistentVolumeClaims (PVCs) for persistent storage. For simplicity, I will assume you have a default storage class configured.

### Step 1: Create a Secret for MySQL Password

Create a Kubernetes Secret to securely store the MySQL root password and WordPress database password.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  # Base64 encoded "yourpassword"
  mysql-root-password: eW91cnBhc3N3b3Jk
  mysql-password: eW91cnBhc3N3b3Jk
```

### Step 2: Create PersistentVolumeClaims

Create PersistentVolumeClaims to store MySQL data and WordPress files persistently.

#### MySQL PVC

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

#### WordPress PVC

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### Step 3: Create MySQL Deployment

Create a Deployment for MySQL with the necessary environment variables and volume mounts.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.7
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-root-password
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpress
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 4: Create the MySQL Service

Expose MySQL through a Service within the cluster.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
```

### Step 5: Create WordPress Deployment

Create the WordPress Deployment, connect it with the MySQL database, and use the required environment variables.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - image: wordpress:latest
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql:3306
        - name: WORDPRESS_DB_USER
          value: wordpress
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: mysql-password
        - name: WORDPRESS_DB_NAME
          value: wordpress
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pv-claim
```

### Step 6: Create the WordPress Service

Expose the WordPress deployment to allow external traffic.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
    - port: 80
  selector:
    app: wordpress
```

### Summary

By following these steps, you create a functioning WordPress blog using MySQL as the backend, deployed on Kubernetes. The configuration includes Secrets for sensitive data and PersistentVolumeClaims for data persistence. Adjust storage sizes, passwords, and images as needed for your environment. Make sure your cluster supports `LoadBalancer` type Services, or change the service type as needed for your Kubernetes environment.