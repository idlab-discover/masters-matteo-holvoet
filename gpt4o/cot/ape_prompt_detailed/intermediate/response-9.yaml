Certainly! Designing a Kubernetes solution to deploy a WordPress site with a MySQL backend involves several components. Letâ€™s tackle this step-by-step:

### Step 1: Create a Secret for MySQL Password

First, we need a Kubernetes Secret for storing the MySQL root and WordPress user password securely.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  root-password: c3VwZXJzZWNyZXQ= # Base64 for "supersecret"
  wordpress-password: d29yZHByZXNz # Base64 for "wordpress"
```

### Step 2: Create a ConfigMap for WordPress Configuration

Next, create a ConfigMap to store MySQL connection details that the WordPress container will use.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  WORDPRESS_DB_HOST: mysql
  WORDPRESS_DB_USER: wordpress
  WORDPRESS_DB_NAME: wordpress
```

### Step 3: PersistentVolumeClaim for MySQL

Set up a PersistentVolumeClaim for MySQL to ensure database persistence.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### Step 4: MySQL Deployment

Define a Deployment for MySQL, mounting the PersistentVolumeClaim and using environment variables for configuration.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-pass
                  key: root-password
            - name: MYSQL_DATABASE
              value: wordpress
            - name: MYSQL_USER
              value: wordpress
            - name: MYSQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-pass
                  key: wordpress-password
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mysql-persistent-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-persistent-storage
          persistentVolumeClaim:
            claimName: mysql-pv-claim
```

### Step 5: MySQL Service

Expose MySQL service to other pods in the same namespace.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  selector:
    app: mysql
  ports:
    - port: 3306
```

### Step 6: WordPress Deployment

Create a WordPress Deployment using the pre-defined ConfigMap and Secret for configuration.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
        - name: wordpress
          image: wordpress:latest
          env:
            - name: WORDPRESS_DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: wordpress-config
                  key: WORDPRESS_DB_HOST
            - name: WORDPRESS_DB_USER
              valueFrom:
                configMapKeyRef:
                  name: wordpress-config
                  key: WORDPRESS_DB_USER
            - name: WORDPRESS_DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: wordpress-config
                  key: WORDPRESS_DB_NAME
            - name: WORDPRESS_DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-pass
                  key: wordpress-password
          ports:
            - containerPort: 80
```

### Step 7: WordPress Service

Finally, create a Service to expose WordPress.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  selector:
    app: wordpress
  ports:
    - port: 80
  type: LoadBalancer
```

### Summary

This setup configures WordPress and MySQL deployments with persistence, configures the WordPress deployment using environment variables from ConfigMaps and Secrets, and exposes both WordPress and MySQL using Kubernetes Services. We are using a PersistentVolumeClaim to ensure MySQL's data is stored persistently. This manifests are suitable for a basic WordPress site setup on Kubernetes.