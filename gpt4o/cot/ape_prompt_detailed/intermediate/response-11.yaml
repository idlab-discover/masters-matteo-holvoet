Certainly! Deploying a WordPress website with a MySQL backend involves several components in Kubernetes, such as Deployment objects, Services, Persistent Volume Claims, ConfigMaps, and Secrets. We'll break it down step-by-step:

### Step 1: Create a Secret for MySQL Credentials

First, you need to store sensitive information such as the MySQL root password, WordPress database name, user, and password in a Kubernetes Secret.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  mysql-root-password: <base64-root-password>
  mysql-user: <base64-wordpress-username>
  mysql-password: <base64-wordpress-password>
  mysql-database: <base64-wordpress-database>
```

Replace the placeholder values with base64 encoded strings of your database name, username, and passwords. You can generate them using `echo -n 'your-value' | base64`.

### Step 2: Create a ConfigMap for MySQL Configuration

If needed, you can use a ConfigMap for non-sensitive configuration data. In this example, we'll assume there's no extra configuration for MySQL.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  # Add any configuration data if necessary
```

### Step 3: Create PersistentVolumes and PersistentVolumeClaims

We need persistent storage for the MySQL database.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### Step 4: Create the MySQL Deployment

Create a Deployment for the MySQL container to use this persistent volume.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-root-password
        - name: MYSQL_DATABASE
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-database
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-user
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        ports:
        - containerPort: 3306
        volumeMounts:
        - mountPath: /var/lib/mysql
          name: mysql-persistent-storage
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 5: Create a Service for MySQL

We need a Service to expose the MySQL Deployment internally.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
```

### Step 6: Create the WordPress Deployment

Next, create a Deployment for WordPress. It will connect to the MySQL service via the environment variables.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_NAME
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-database
        - name: WORDPRESS_DB_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-user
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
```

### Step 7: Create a Service for WordPress

Finally, provide access to the WordPress container.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
    - port: 80
  selector:
    app: wordpress
```

This `Service` is set to `LoadBalancer` type, which is suitable for cloud providers that automatically provision external IPs.

### Bringing It All Together

It helps to apply these configurations in order using `kubectl apply -f <filename>` for each of the YAML sections mentioned. Make any necessary modifications specific to your Kubernetes environment or additional application needs.

This complete set of manifests covers creating persistent storage, handling sensitive data with Secrets, and setting up Deployments and Services for WordPress and MySQL on Kubernetes.