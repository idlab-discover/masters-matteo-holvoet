Sure, let's break down the task of deploying a WordPress website with a MySQL backend on Kubernetes using YAML manifest files. We'll use best practices by employing ConfigMaps and Secrets for configuration management and sensitive data handling, as well as Persistent Volumes for data persistence.

### Step 1: Create a Secret for MySQL

First, we'll create a Secret to store the MySQL root password and the WordPress database password. This way, these sensitive pieces of information are not stored in plain text in our deployment files.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  mysql-root-password: <base64_root_password>
  mysql-password: <base64_wordpress_password>
```

Replace `<base64_root_password>` and `<base64_wordpress_password>` with the base64-encoded string of your desired passwords.

### Step 2: Create a ConfigMap for WordPress

Next, we'll create a ConfigMap to manage configurations for WordPress. 

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  WORDPRESS_DB_NAME: wordpress
  WORDPRESS_DB_USER: wordpress
```

### Step 3: Create PersistentVolumeClaims

We'll need to create PersistentVolumeClaims (PVCs) for MySQL to ensure its data persists across pod restarts and updates.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### Step 4: Create the MySQL Deployment

The MySQL deployment will use the Secret and PVC defined earlier.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-root-password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_NAME
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_USER
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

### Step 5: Create the MySQL Service

Create a Service to expose MySQL to the WordPress application.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
  clusterIP: None # headless service for better connection between WP and MySQL
```

### Step 6: Create the WordPress Deployment

Here's the WordPress deployment, which connects to MySQL using the Service and Secret.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:php7.4-fpm
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_NAME
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_USER
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
```

### Step 7: Create the WordPress Service

Finally, we'll create a Service to expose WordPress to external users.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
    - port: 80
  selector:
    app: wordpress
```

### Summary

By following this setup, we have:
- A Secret to hold sensitive data like passwords.
- A ConfigMap to manage non-sensitive configuration details.
- PersistentVolumeClaims for MySQL's data persistence.
- Deployments and Services for both WordPress and MySQL, ensuring connectivity between them.

Remember to update your Kubernetes cluster with the actual base64 encoded values for the passwords and check your cloud setup if you're using a LoadBalancer type for the WordPress Service. Adjust resources based on your actual requirements and environment.