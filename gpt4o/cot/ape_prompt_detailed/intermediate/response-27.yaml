Creating a Kubernetes deployment for a WordPress website with a MySQL database involves several components. We'll go through each step to ensure everything is covered, from creating a Deployment for both WordPress and MySQL, to setting up Services, ConfigMaps, Secrets, and PersistentVolumes.

### Step 1: Create Secret for MySQL Password

We'll store the MySQL password in a Secret to keep it secure.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  mysql-root-password: <base64-encoded-password>
  mysql-password: <base64-encoded-password>
```

*Note: Replace `<base64-encoded-password>` with the base64 encoded version of your desired password.*

### Step 2: Create a ConfigMap for WordPress

The ConfigMap will store configuration data that is not sensitive.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  WORDPRESS_DB_HOST: mysql
  WORDPRESS_DB_NAME: wordpress
```

### Step 3: Create PersistentVolumeClaims for MySQL

We'll use PersistentVolumeClaims to ensure MySQL data persists.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### Step 4: Create MySQL Deployment

Now, create the Deployment for MySQL.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-root-password
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpress
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        ports:
        - containerPort: 3306
        volumeMounts:
        - mountPath: /var/lib/mysql
          name: mysql-storage
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```

### Step 5: Create WordPress Deployment

Now, create the Deployment for WordPress.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        env:
        - name: WORDPRESS_DB_HOST
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_HOST
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: wordpress-config
              key: WORDPRESS_DB_NAME
        - name: WORDPRESS_DB_USER
          value: wordpress
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        ports:
        - containerPort: 80
```

### Step 6: Create Services for MySQL and WordPress

Let's expose both MySQL and WordPress via Services.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer # Use LoadBalancer for external access, or NodePort or ClusterIP according to setup
  ports:
  - port: 80
  selector:
    app: wordpress
```

### Summary

By following these steps, we have created a comprehensive setup for running a WordPress site on Kubernetes with a MySQL backend. The configurations ensure separation of concerns with ConfigMaps for general configurations and Secrets for sensitive information. We have also covered data persistence for MySQL using PersistentVolumeClaims and exposed the services for both pods.

Make sure you adjust the specifics to match your Kubernetes cluster's capabilities and security requirements.