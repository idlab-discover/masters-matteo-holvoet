Sure, let's break down the task into smaller parts to create a complete Kubernetes YAML manifest for deploying a WordPress site with a MySQL database backend. We'll need to configure Deployments, Services, PersistentVolumeClaims (PVCs), ConfigMaps, and Secrets.

### Step 1: Create the Secret for MySQL

We'll create a Secret to hold sensitive data like the MySQL root password and the WordPress database user password.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  mysql-root-password: <base64-encoded-root-password>
  mysql-password: <base64-encoded-wordpress-password>
```

Please note: You need to replace `<base64-encoded-root-password>` and `<base64-encoded-wordpress-password>` with the base64-encoded values of your actual passwords.

### Step 2: Create a ConfigMap for MySQL

A ConfigMap can be used to store non-sensitive configuration data. We'll configure the MySQL database name and user here.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  database: wordpress
  username: wordpress-user
```

### Step 3: Create the MySQL Deployment and Service

We'll set up a Deployment for MySQL that uses a PersistentVolumeClaim for data persistence and a Service for connectivity.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-root-password
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: database
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: username
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
  selector:
    app: mysql
```

### Step 4: Create the WordPress Deployment and Service

This step involves creating a Deployment for WordPress configured to connect to the MySQL database, and a Service for access.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_USER
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: username
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: mysql-password
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: database
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: wordpress
```

With these steps, you have a Kubernetes YAML manifest that:

1. Uses Secrets for sensitive data.
2. Utilizes ConfigMaps for configuration.
3. Deploys MySQL with persistent storage.
4. Deploys WordPress connected to the MySQL database.
5. Exposes both services for internal and external access. 

Remember to replace base64-encoded values with actual encoded data for Secret creation and ensure your Kubernetes environment supports `LoadBalancer` services, or adjust the type according to your setup.