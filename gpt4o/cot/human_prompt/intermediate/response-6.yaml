Deploying a WordPress website with a MySQL backend on Kubernetes involves several steps. You'll need to create a set of Kubernetes resources, including PersistentVolumeClaims for storing data, Deployment resources for managing the pods, and Services for exposing the deployments. Here's a step-by-step guide with YAML manifests for deploying WordPress and MySQL on Kubernetes.

### Step 1: Create a Persistent Volume Claim for MySQL

First, define a PersistentVolumeClaim for MySQL to store the database data.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### Step 2: Create a Deployment for MySQL

Now, create a MySQL Deployment. This will include a volume to persist the MySQL data.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.7
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: my-secret-pw
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
```

### Step 3: Create a Service for MySQL

We'll also need a Service to expose the MySQL Deployment internally to the WordPress Deployment.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
  - port: 3306
    targetPort: 3306
  selector:
    app: mysql
```

### Step 4: Create a Persistent Volume Claim for WordPress

Now, define a PersistentVolumeClaim for WordPress to store its data.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### Step 5: Create a Deployment for WordPress

Proceed to create a WordPress Deployment. This will connect to the MySQL service through environment variables.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - image: wordpress:latest
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql
        - name: WORDPRESS_DB_PASSWORD
          value: my-secret-pw
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc
```

### Step 6: Create a Service for WordPress

Finally, create a Service to expose the WordPress Deployment externally.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: wordpress
```

### Summary

By following these steps, you've defined the necessary Kubernetes resources to run WordPress with MySQL as a backend. You have created PersistentVolumeClaims for both MySQL and WordPress, set up Deployments to manage their respective containers, and exposed them via Services. 

Deploy these YAML configurations to your Kubernetes cluster using `kubectl apply -f <filename.yaml>` for each file, or combine them into a single file and apply that. Make sure to replace the placeholder values, such as passwords, with ones that suit your security requirements.