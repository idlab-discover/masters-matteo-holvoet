To deploy a WordPress website on Kubernetes with a MySQL backend, we need to create several Kubernetes objects including PersistentVolume (PV), PersistentVolumeClaim (PVC), Secrets, Deployments, and Services. This breakdown will help you understand the creation of a WordPress and MySQL deployment step-by-step.

### Step 1: Create Persistent Volumes and Claims
First, we need storage for both WordPress and MySQL data. This ensures that data persists even if the Pods are restarted.

```yaml
# persistent-volume.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
spec:
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 20Gi
  hostPath:
    path: /mnt/data/mysql

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: wordpress-pv
spec:
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 10Gi
  hostPath:
    path: /mnt/data/wordpress

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wordpress-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Step 2: Create MySQL Secret
Create a secret to store MySQL credentials securely.

```yaml
# mysql-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
type: Opaque
data:
  # Echo the password and then base64 encode it, e.g., echo -n 'yourpassword' | base64
  password: d2twb3JkcHJlc3Mh
```

### Step 3: Deploy MySQL
Define the Deployment and Service for the MySQL database.

```yaml
# mysql-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.7
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: MYSQL_DATABASE
          value: wordpress
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
```

### Step 4: Deploy WordPress
Define the Deployment and Service for WordPress.

```yaml
# wordpress-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - image: wordpress:latest
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql:3306
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wordpress-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

### Deployment Instructions

1. Apply the `persistent-volume.yaml` file:
   ```bash
   kubectl apply -f persistent-volume.yaml
   ```

2. Apply the `mysql-secret.yaml` file:
   ```bash
   kubectl apply -f mysql-secret.yaml
   ```

3. Deploy MySQL by applying the `mysql-deployment.yaml` file:
   ```bash
   kubectl apply -f mysql-deployment.yaml
   ```

4. Deploy WordPress by applying the `wordpress-deployment.yaml` file:
   ```bash
   kubectl apply -f wordpress-deployment.yaml
   ```

Now, if everything is configured correctly, your WordPress site should be accessible via the external IP associated with the WordPress Service. This assumes that your Kubernetes cluster is set up correctly to handle LoadBalancer services. Adjust storage and configurations according to the specific needs of your environment.