Sure, let's create a Kubernetes YAML manifest to deploy a WordPress website with a MySQL database as the backend. We will go through the components step by step:

### Step 1: Create MySQL Secret

First, we'll define a Secret for the MySQL credentials. This is important to store sensitive data such as passwords securely.

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
data:
  mysql-root-password: <base64-encoded-root-password>
  mysql-user-password: <base64-encoded-user-password>
```

Replace `<base64-encoded-root-password>` and `<base64-encoded-user-password>` with your Base64-encoded root and user passwords.

### Step 2: Define PersistentVolumeClaim for MySQL

We need a PersistentVolumeClaim for the MySQL data to ensure data persistence.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### Step 3: Define ConfigMap for WordPress Configuration

We'll define a ConfigMap for any non-sensitive configuration data that WordPress might need.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  WORDPRESS_DB_HOST: mysql:3306
  WORDPRESS_TABLE_PREFIX: wp_
```

### Step 4: Create MySQL Deployment

Next, we define the Deployment for the MySQL container.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: mysql-root-password
            - name: MYSQL_DATABASE
              value: wordpress
            - name: MYSQL_USER
              value: wpuser
            - name: MYSQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: mysql-user-password
          volumeMounts:
            - name: mysql-persistent-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-persistent-storage
          persistentVolumeClaim:
            claimName: mysql-pv-claim
```

### Step 5: Create MySQL Service

We need a Service to expose the MySQL deployment internally within the cluster.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
  clusterIP: None
```

### Step 6: Create WordPress Deployment

We'll now define the Deployment for the WordPress container.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
        - name: wordpress
          image: wordpress:5.7
          ports:
            - containerPort: 80
          env:
            - name: WORDPRESS_DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: wordpress-config
                  key: WORDPRESS_DB_HOST
            - name: WORDPRESS_DB_USER
              value: wpuser
            - name: WORDPRESS_DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: mysql-user-password
            - name: WORDPRESS_DB_NAME
              value: wordpress
```

### Step 7: Create WordPress Service

Finally, we need a Service to expose the WordPress deployment appropriately.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

The `type: LoadBalancer` will expose the WordPress service to the external world if you're running this on a cloud provider that supports LoadBalancer services.

### Conclusion

These YAML manifests set up a WordPress site backed by a MySQL database with persistence and configuration management using ConfigMaps and Secrets. Make sure to replace the password values with your actual passwords encoded in Base64 before applying these manifests to your Kubernetes cluster.