To deploy a WordPress website with a MySQL database in Kubernetes, we'll follow these steps:

1. **Create a Secret for MySQL Password**: Store sensitive data like the MySQL password using Kubernetes Secrets.

2. **Create a ConfigMap for WordPress Configuration**: Store non-sensitive data using ConfigMaps.

3. **Create PersistentVolumeClaims (PVCs)**: Ensure data persistence for MySQL by setting up PVCs.

4. **Create a MySQL Deployment and Service**: Set up the MySQL container, configure the deployment with PVCs, and expose it via a Service.

5. **Create a WordPress Deployment and Service**: Deploy WordPress and ensure it can connect to the MySQL database using proper environment variables.

Let's create each of these components. For simplicity, I'll use example values and basic resources. You may need to adjust the resource requests/limits based on your environment and anticipated load.

### Step 1: Create the Secret

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  mysql-root-password: dXNlclNlY3JldA==  # base64 encoded value of 'userSecret' 
```

### Step 2: Create the ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  WORDPRESS_DB_HOST: mysql
  WORDPRESS_DB_USER: root
```

### Step 3: Create the PersistentVolumeClaims

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

### Step 4: Create the MySQL Deployment and Service

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  selector:
    matchLabels:
      app: mysql
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
        - name: mysql
          image: mysql:5.7
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: mysql-root-password
          volumeMounts:
            - name: mysql-persistent-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-persistent-storage
          persistentVolumeClaim:
            claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
```

### Step 5: Create the WordPress Deployment and Service

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
  replicas: 1
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
        - name: wordpress
          image: wordpress:latest
          ports:
            - containerPort: 80
          env:
            - name: WORDPRESS_DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: wordpress-config
                  key: WORDPRESS_DB_HOST
            - name: WORDPRESS_DB_USER
              valueFrom:
                configMapKeyRef:
                  name: wordpress-config
                  key: WORDPRESS_DB_USER
            - name: WORDPRESS_DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-secret
                  key: mysql-root-password
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
  type: LoadBalancer
```

This manifests setup a basic WordPress and MySQL deployment in a Kubernetes cluster. You need to have persistent storage available for the PVCs, and your cluster should support LoadBalancer type services, or you can change it to NodePort if necessary based on your infrastructure. Adjust the configurations as needed based on your specific requirements and environment.